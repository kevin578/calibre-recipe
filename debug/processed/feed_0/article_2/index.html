<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>You-Dont-Know-JS/ch1.md at master · getify/You-Dont-Know-JS · GitHub</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><div class="calibre_navbar">| <a href="../article_3/index.html">Next</a> | <a href="../index.html#article_2">Section menu</a> | <a href="../../index.html#feed_0">Main menu</a> | <a href="../article_1/index.html">Previous</a> | <hr class="calibre6"/>
</div><div class="calibre5"><div itemprop="text" class="calibre5"><h1 class="calibre7"><a id="user-content-you-dont-know-js-scope--closures" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#you-dont-know-js-scope--closures"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>You Don't Know JS: Scope &amp; Closures</h1>
<h1 class="calibre7"><a id="user-content-chapter-1-what-is-scope" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#chapter-1-what-is-scope"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Chapter 1: What is Scope?</h1>
<p class="calibre8">One of the most fundamental paradigms of nearly all programming languages is the ability to store values in variables, and later retrieve or modify those values. In fact, the ability to store values and pull values out of variables is what gives a program <em class="calibre9">state</em>.</p>
<p class="calibre8">Without such a concept, a program could perform some tasks, but they would be extremely limited and not terribly interesting.</p>
<p class="calibre8">But the inclusion of variables into our program begets the most interesting questions we will now address: where do those variables <em class="calibre9">live</em>? In other words, where are they stored? And, most importantly, how does our program find them when it needs them?</p>
<p class="calibre8">These questions speak to the need for a well-defined set of rules for storing variables in some location, and for finding those variables at a later time. We'll call that set of rules: <em class="calibre9">Scope</em>.</p>
<p class="calibre8">But, where and how do these <em class="calibre9">Scope</em> rules get set?</p>
<h2 class="calibre10"><a id="user-content-compiler-theory" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#compiler-theory"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Compiler Theory</h2>
<p class="calibre8">It may be self-evident, or it may be surprising, depending on your level of interaction with various languages, but despite the fact that JavaScript falls under the general category of "dynamic" or "interpreted" languages, it is in fact a compiled language. It is <em class="calibre9">not</em> compiled well in advance, as are many traditionally-compiled languages, nor are the results of compilation portable among various distributed systems.</p>
<p class="calibre8">But, nevertheless, the JavaScript engine performs many of the same steps, albeit in more sophisticated ways than we may commonly be aware, of any traditional language-compiler.</p>
<p class="calibre8">In traditional compiled-language process, a chunk of source code, your program, will undergo typically three steps <em class="calibre9">before</em> it is executed, roughly called "compilation":</p>
<ol class="calibre13">
<li class="calibre4">
<p class="calibre8"><strong class="calibre12">Tokenizing/Lexing:</strong> breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: <code class="calibre14">var a = 2;</code>. This program would likely be broken up into the following tokens: <code class="calibre14">var</code>, <code class="calibre14">a</code>, <code class="calibre14">=</code>, <code class="calibre14">2</code>, and <code class="calibre14">;</code>. Whitespace may or may not be persisted as a token, depending on whether it's meaningful or not.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a <em class="calibre9">stateless</em> or <em class="calibre9">stateful</em> way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether <code class="calibre14">a</code> should be considered a distinct token or just part of another token, <em class="calibre9">that</em> would be <strong class="calibre12">lexing</strong>.</p>
</li>
<li class="calibre4">
<p class="calibre8"><strong class="calibre12">Parsing:</strong> taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This tree is called an "AST" (<b class="calibre12">A</b>bstract <b class="calibre12">S</b>yntax <b class="calibre12">T</b>ree).</p>
<p class="calibre8">The tree for <code class="calibre14">var a = 2;</code> might start with a top-level node called <code class="calibre14">VariableDeclaration</code>, with a child node called <code class="calibre14">Identifier</code> (whose value is <code class="calibre14">a</code>), and another child called <code class="calibre14">AssignmentExpression</code> which itself has a child called <code class="calibre14">NumericLiteral</code> (whose value is <code class="calibre14">2</code>).</p>
</li>
<li class="calibre4">
<p class="calibre8"><strong class="calibre12">Code-Generation:</strong> the process of taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it's targeting, etc.</p>
<p class="calibre8">So, rather than get mired in details, we'll just handwave and say that there's a way to take our above described AST for <code class="calibre14">var a = 2;</code> and turn it into a set of machine instructions to actually <em class="calibre9">create</em> a variable called <code class="calibre14">a</code> (including reserving memory, etc.), and then store a value into <code class="calibre14">a</code>.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> The details of how the engine manages system resources are deeper than we will dig, so we'll just take it for granted that the engine is able to create and store variables as needed.</p>
</li>
</ol>
<p class="calibre8">The JavaScript engine is vastly more complex than <em class="calibre9">just</em> those three steps, as are most other language compilers. For instance, in the process of parsing and code-generation, there are certainly steps to optimize the performance of the execution, including collapsing redundant elements, etc.</p>
<p class="calibre8">So, I'm painting only with broad strokes here. But I think you'll see shortly why <em class="calibre9">these</em> details we <em class="calibre9">do</em> cover, even at a high level, are relevant.</p>
<p class="calibre8">For one thing, JavaScript engines don't get the luxury (like other language compilers) of having plenty of time to optimize, because JavaScript compilation doesn't happen in a build step ahead of time, as with other languages.</p>
<p class="calibre8">For JavaScript, the compilation that occurs happens, in many cases, mere microseconds (or less!) before the code is executed. To ensure the fastest performance, JS engines use all kinds of tricks (like JITs, which lazy compile and even hot re-compile, etc.) which are well beyond the "scope" of our discussion here.</p>
<p class="calibre8">Let's just say, for simplicity's sake, that any snippet of JavaScript has to be compiled before (usually <em class="calibre9">right</em> before!) it's executed. So, the JS compiler will take the program <code class="calibre14">var a = 2;</code> and compile it <em class="calibre9">first</em>, and then be ready to execute it, usually right away.</p>
<h2 class="calibre10"><a id="user-content-understanding-scope" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#understanding-scope"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Understanding Scope</h2>
<p class="calibre8">The way we will approach learning about scope is to think of the process in terms of a conversation. But, <em class="calibre9">who</em> is having the conversation?</p>
<h3 class="calibre15"><a id="user-content-the-cast" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#the-cast"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>The Cast</h3>
<p class="calibre8">Let's meet the cast of characters that interact to process the program <code class="calibre14">var a = 2;</code>, so we understand their conversations that we'll listen in on shortly:</p>
<ol class="calibre13">
<li class="calibre4">
<p class="calibre8"><em class="calibre9">Engine</em>: responsible for start-to-finish compilation and execution of our JavaScript program.</p>
</li>
<li class="calibre4">
<p class="calibre8"><em class="calibre9">Compiler</em>: one of <em class="calibre9">Engine</em>'s friends; handles all the dirty work of parsing and code-generation (see previous section).</p>
</li>
<li class="calibre4">
<p class="calibre8"><em class="calibre9">Scope</em>: another friend of <em class="calibre9">Engine</em>; collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.</p>
</li>
</ol>
<p class="calibre8">For you to <em class="calibre9">fully understand</em> how JavaScript works, you need to begin to <em class="calibre9">think</em> like <em class="calibre9">Engine</em> (and friends) think, ask the questions they ask, and answer those questions the same.</p>
<h3 class="calibre15"><a id="user-content-back--forth" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#back--forth"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Back &amp; Forth</h3>
<p class="calibre8">When you see the program <code class="calibre14">var a = 2;</code>, you most likely think of that as one statement. But that's not how our new friend <em class="calibre9">Engine</em> sees it. In fact, <em class="calibre9">Engine</em> sees two distinct statements, one which <em class="calibre9">Compiler</em> will handle during compilation, and one which <em class="calibre9">Engine</em> will handle during execution.</p>
<p class="calibre8">So, let's break down how <em class="calibre9">Engine</em> and friends will approach the program <code class="calibre14">var a = 2;</code>.</p>
<p class="calibre8">The first thing <em class="calibre9">Compiler</em> will do with this program is perform lexing to break it down into tokens, which it will then parse into a tree. But when <em class="calibre9">Compiler</em> gets to code-generation, it will treat this program somewhat differently than perhaps assumed.</p>
<p class="calibre8">A reasonable assumption would be that <em class="calibre9">Compiler</em> will produce code that could be summed up by this pseudo-code: "Allocate memory for a variable, label it <code class="calibre14">a</code>, then stick the value <code class="calibre14">2</code> into that variable." Unfortunately, that's not quite accurate.</p>
<p class="calibre8"><em class="calibre9">Compiler</em> will instead proceed as:</p>
<ol class="calibre13">
<li class="calibre4">
<p class="calibre8">Encountering <code class="calibre14">var a</code>, <em class="calibre9">Compiler</em> asks <em class="calibre9">Scope</em> to see if a variable <code class="calibre14">a</code> already exists for that particular scope collection. If so, <em class="calibre9">Compiler</em> ignores this declaration and moves on. Otherwise, <em class="calibre9">Compiler</em> asks <em class="calibre9">Scope</em> to declare a new variable called <code class="calibre14">a</code> for that scope collection.</p>
</li>
<li class="calibre4">
<p class="calibre8"><em class="calibre9">Compiler</em> then produces code for <em class="calibre9">Engine</em> to later execute, to handle the <code class="calibre14">a = 2</code> assignment. The code <em class="calibre9">Engine</em> runs will first ask <em class="calibre9">Scope</em> if there is a variable called <code class="calibre14">a</code> accessible in the current scope collection. If so, <em class="calibre9">Engine</em> uses that variable. If not, <em class="calibre9">Engine</em> looks <em class="calibre9">elsewhere</em> (see nested <em class="calibre9">Scope</em> section below).</p>
</li>
</ol>
<p class="calibre8">If <em class="calibre9">Engine</em> eventually finds a variable, it assigns the value <code class="calibre14">2</code> to it. If not, <em class="calibre9">Engine</em> will raise its hand and yell out an error!</p>
<p class="calibre8">To summarize: two distinct actions are taken for a variable assignment: First, <em class="calibre9">Compiler</em> declares a variable (if not previously declared in the current scope), and second, when executing, <em class="calibre9">Engine</em> looks up the variable in <em class="calibre9">Scope</em> and assigns to it, if found.</p>
<h3 class="calibre15"><a id="user-content-compiler-speak" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#compiler-speak"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Compiler Speak</h3>
<p class="calibre8">We need a little bit more compiler terminology to proceed further with understanding.</p>
<p class="calibre8">When <em class="calibre9">Engine</em> executes the code that <em class="calibre9">Compiler</em> produced for step (2), it has to look-up the variable <code class="calibre14">a</code> to see if it has been declared, and this look-up is consulting <em class="calibre9">Scope</em>. But the type of look-up <em class="calibre9">Engine</em> performs affects the outcome of the look-up.</p>
<p class="calibre8">In our case, it is said that <em class="calibre9">Engine</em> would be performing an "LHS" look-up for the variable <code class="calibre14">a</code>. The other type of look-up is called "RHS".</p>
<p class="calibre8">I bet you can guess what the "L" and "R" mean. These terms stand for "Left-hand Side" and "Right-hand Side".</p>
<p class="calibre8">Side... of what? <strong class="calibre12">Of an assignment operation.</strong></p>
<p class="calibre8">In other words, an LHS look-up is done when a variable appears on the left-hand side of an assignment operation, and an RHS look-up is done when a variable appears on the right-hand side of an assignment operation.</p>
<p class="calibre8">Actually, let's be a little more precise. An RHS look-up is indistinguishable, for our purposes, from simply a look-up of the value of some variable, whereas the LHS look-up is trying to find the variable container itself, so that it can assign. In this way, RHS doesn't <em class="calibre9">really</em> mean "right-hand side of an assignment" per se, it just, more accurately, means "not left-hand side".</p>
<p class="calibre8">Being slightly glib for a moment, you could also think "RHS" instead means "retrieve his/her source (value)", implying that RHS means "go get the value of...".</p>
<p class="calibre8">Let's dig into that deeper.</p>
<p class="calibre8">When I say:</p>
<p class="calibre8">The reference to <code class="calibre14">a</code> is an RHS reference, because nothing is being assigned to <code class="calibre14">a</code> here. Instead, we're looking-up to retrieve the value of <code class="calibre14">a</code>, so that the value can be passed to <code class="calibre14">console.log(..)</code>.</p>
<p class="calibre8">By contrast:</p>
<p class="calibre8">The reference to <code class="calibre14">a</code> here is an LHS reference, because we don't actually care what the current value is, we simply want to find the variable as a target for the <code class="calibre14">= 2</code> assignment operation.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> LHS and RHS meaning "left/right-hand side of an assignment" doesn't necessarily literally mean "left/right side of the <code class="calibre14">=</code> assignment operator". There are several other ways that assignments happen, and so it's better to conceptually think about it as: "who's the target of the assignment (LHS)" and "who's the source of the assignment (RHS)".</p>
<p class="calibre8">Consider this program, which has both LHS and RHS references:</p>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>a</span>) {
	<span>console</span>.<span>log</span>( a ); <span><span>//</span> 2</span>
}

<span>foo</span>( <span>2</span> );</pre></div>
<p class="calibre8">The last line that invokes <code class="calibre14">foo(..)</code> as a function call requires an RHS reference to <code class="calibre14">foo</code>, meaning, "go look-up the value of <code class="calibre14">foo</code>, and give it to me." Moreover, <code class="calibre14">(..)</code> means the value of <code class="calibre14">foo</code> should be executed, so it'd better actually be a function!</p>
<p class="calibre8">There's a subtle but important assignment here. <strong class="calibre12">Did you spot it?</strong></p>
<p class="calibre8">You may have missed the implied <code class="calibre14">a = 2</code> in this code snippet. It happens when the value <code class="calibre14">2</code> is passed as an argument to the <code class="calibre14">foo(..)</code> function, in which case the <code class="calibre14">2</code> value is <strong class="calibre12">assigned</strong> to the parameter <code class="calibre14">a</code>. To (implicitly) assign to parameter <code class="calibre14">a</code>, an LHS look-up is performed.</p>
<p class="calibre8">There's also an RHS reference for the value of <code class="calibre14">a</code>, and that resulting value is passed to <code class="calibre14">console.log(..)</code>. <code class="calibre14">console.log(..)</code> needs a reference to execute. It's an RHS look-up for the <code class="calibre14">console</code> object, then a property-resolution occurs to see if it has a method called <code class="calibre14">log</code>.</p>
<p class="calibre8">Finally, we can conceptualize that there's an LHS/RHS exchange of passing the value <code class="calibre14">2</code> (by way of variable <code class="calibre14">a</code>'s RHS look-up) into <code class="calibre14">log(..)</code>. Inside of the native implementation of <code class="calibre14">log(..)</code>, we can assume it has parameters, the first of which (perhaps called <code class="calibre14">arg1</code>) has an LHS reference look-up, before assigning <code class="calibre14">2</code> to it.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> You might be tempted to conceptualize the function declaration <code class="calibre14">function foo(a) {...</code> as a normal variable declaration and assignment, such as <code class="calibre14">var foo</code> and <code class="calibre14">foo = function(a){...</code>. In so doing, it would be tempting to think of this function declaration as involving an LHS look-up.</p>
<p class="calibre8">However, the subtle but important difference is that <em class="calibre9">Compiler</em> handles both the declaration and the value definition during code-generation, such that when <em class="calibre9">Engine</em> is executing code, there's no processing necessary to "assign" a function value to <code class="calibre14">foo</code>. Thus, it's not really appropriate to think of a function declaration as an LHS look-up assignment in the way we're discussing them here.</p>
<h3 class="calibre15"><a id="user-content-enginescope-conversation" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#enginescope-conversation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Engine/Scope Conversation</h3>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>a</span>) {
	<span>console</span>.<span>log</span>( a ); <span><span>//</span> 2</span>
}

<span>foo</span>( <span>2</span> );</pre></div>
<p class="calibre8">Let's imagine the above exchange (which processes this code snippet) as a conversation. The conversation would go a little something like this:</p>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: Hey <em class="calibre9">Scope</em>, I have an RHS reference for <code class="calibre14">foo</code>. Ever heard of it?</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Scope</strong></em>: Why yes, I have. <em class="calibre9">Compiler</em> declared it just a second ago. He's a function. Here you go.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: Great, thanks! OK, I'm executing <code class="calibre14">foo</code>.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: Hey, <em class="calibre9">Scope</em>, I've got an LHS reference for <code class="calibre14">a</code>, ever heard of it?</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Scope</strong></em>: Why yes, I have. <em class="calibre9">Compiler</em> declared it as a formal parameter to <code class="calibre14">foo</code> just recently. Here you go.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: Helpful as always, <em class="calibre9">Scope</em>. Thanks again. Now, time to assign <code class="calibre14">2</code> to <code class="calibre14">a</code>.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: Hey, <em class="calibre9">Scope</em>, sorry to bother you again. I need an RHS look-up for <code class="calibre14">console</code>. Ever heard of it?</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Scope</strong></em>: No problem, <em class="calibre9">Engine</em>, this is what I do all day. Yes, I've got <code class="calibre14">console</code>. He's built-in. Here ya go.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: Perfect. Looking up <code class="calibre14">log(..)</code>. OK, great, it's a function.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: Yo, <em class="calibre9">Scope</em>. Can you help me out with an RHS reference to <code class="calibre14">a</code>. I think I remember it, but just want to double-check.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Scope</strong></em>: You're right, <em class="calibre9">Engine</em>. Same guy, hasn't changed. Here ya go.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: Cool. Passing the value of <code class="calibre14">a</code>, which is <code class="calibre14">2</code>, into <code class="calibre14">log(..)</code>.</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8">...</p>
</blockquote>
<h3 class="calibre15"><a id="user-content-quiz" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#quiz"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Quiz</h3>
<p class="calibre8">Check your understanding so far. Make sure to play the part of <em class="calibre9">Engine</em> and have a "conversation" with the <em class="calibre9">Scope</em>:</p>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>a</span>) {
	<span>var</span> b <span>=</span> a;
	<span>return</span> a <span>+</span> b;
}

<span>var</span> c <span>=</span> <span>foo</span>( <span>2</span> );</pre></div>
<ol class="calibre13">
<li class="calibre4">
<p class="calibre8">Identify all the LHS look-ups (there are 3!).</p>
</li>
<li class="calibre4">
<p class="calibre8">Identify all the RHS look-ups (there are 4!).</p>
</li>
</ol>
<p class="calibre8"><strong class="calibre12">Note:</strong> See the chapter review for the quiz answers!</p>
<h2 class="calibre10"><a id="user-content-nested-scope" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#nested-scope"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Nested Scope</h2>
<p class="calibre8">We said that <em class="calibre9">Scope</em> is a set of rules for looking up variables by their identifier name. There's usually more than one <em class="calibre9">Scope</em> to consider, however.</p>
<p class="calibre8">Just as a block or function is nested inside another block or function, scopes are nested inside other scopes. So, if a variable cannot be found in the immediate scope, <em class="calibre9">Engine</em> consults the next outer containing scope, continuing until found or until the outermost (aka, global) scope has been reached.</p>
<p class="calibre8">Consider:</p>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>a</span>) {
	<span>console</span>.<span>log</span>( a <span>+</span> b );
}

<span>var</span> b <span>=</span> <span>2</span>;

<span>foo</span>( <span>2</span> ); <span><span>//</span> 4</span></pre></div>
<p class="calibre8">The RHS reference for <code class="calibre14">b</code> cannot be resolved inside the function <code class="calibre14">foo</code>, but it can be resolved in the <em class="calibre9">Scope</em> surrounding it (in this case, the global).</p>
<p class="calibre8">So, revisiting the conversations between <em class="calibre9">Engine</em> and <em class="calibre9">Scope</em>, we'd overhear:</p>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: "Hey, <em class="calibre9">Scope</em> of <code class="calibre14">foo</code>, ever heard of <code class="calibre14">b</code>? Got an RHS reference for it."</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Scope</strong></em>: "Nope, never heard of it. Go fish."</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Engine</strong></em>: "Hey, <em class="calibre9">Scope</em> outside of <code class="calibre14">foo</code>, oh you're the global <em class="calibre9">Scope</em>, ok cool. Ever heard of <code class="calibre14">b</code>? Got an RHS reference for it."</p>
</blockquote>
<blockquote class="calibre17">
<p class="calibre8"><em class="calibre9"><strong class="calibre12">Scope</strong></em>: "Yep, sure have. Here ya go."</p>
</blockquote>
<p class="calibre8">The simple rules for traversing nested <em class="calibre9">Scope</em>: <em class="calibre9">Engine</em> starts at the currently executing <em class="calibre9">Scope</em>, looks for the variable there, then if not found, keeps going up one level, and so on. If the outermost global scope is reached, the search stops, whether it finds the variable or not.</p>
<h3 class="calibre15"><a id="user-content-building-on-metaphors" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#building-on-metaphors"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Building on Metaphors</h3>
<p class="calibre8">To visualize the process of nested <em class="calibre9">Scope</em> resolution, I want you to think of this tall building.</p>
<p class="calibre8"><a target="_blank" href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/fig1.png"><img src="images/img1.png" class="calibre2"/></a></p>
<p class="calibre8">The building represents our program's nested <em class="calibre9">Scope</em> rule set. The first floor of the building represents your currently executing <em class="calibre9">Scope</em>, wherever you are. The top level of the building is the global <em class="calibre9">Scope</em>.</p>
<p class="calibre8">You resolve LHS and RHS references by looking on your current floor, and if you don't find it, taking the elevator to the next floor, looking there, then the next, and so on. Once you get to the top floor (the global <em class="calibre9">Scope</em>), you either find what you're looking for, or you don't. But you have to stop regardless.</p>
<h2 class="calibre10"><a id="user-content-errors" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#errors"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Errors</h2>
<p class="calibre8">Why does it matter whether we call it LHS or RHS?</p>
<p class="calibre8">Because these two types of look-ups behave differently in the circumstance where the variable has not yet been declared (is not found in any consulted <em class="calibre9">Scope</em>).</p>
<p class="calibre8">Consider:</p>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>a</span>) {
	<span>console</span>.<span>log</span>( a <span>+</span> b );
	b <span>=</span> a;
}

<span>foo</span>( <span>2</span> );</pre></div>
<p class="calibre8">When the RHS look-up occurs for <code class="calibre14">b</code> the first time, it will not be found. This is said to be an "undeclared" variable, because it is not found in the scope.</p>
<p class="calibre8">If an RHS look-up fails to ever find a variable, anywhere in the nested <em class="calibre9">Scope</em>s, this results in a <code class="calibre14">ReferenceError</code> being thrown by the <em class="calibre9">Engine</em>. It's important to note that the error is of the type <code class="calibre14">ReferenceError</code>.</p>
<p class="calibre8">By contrast, if the <em class="calibre9">Engine</em> is performing an LHS look-up and arrives at the top floor (global <em class="calibre9">Scope</em>) without finding it, and if the program is not running in "Strict Mode" [^note-strictmode], then the global <em class="calibre9">Scope</em> will create a new variable of that name <strong class="calibre12">in the global scope</strong>, and hand it back to <em class="calibre9">Engine</em>.</p>
<p class="calibre8"><em class="calibre9">"No, there wasn't one before, but I was helpful and created one for you."</em></p>
<p class="calibre8">"Strict Mode" [^note-strictmode], which was added in ES5, has a number of different behaviors from normal/relaxed/lazy mode. One such behavior is that it disallows the automatic/implicit global variable creation. In that case, there would be no global <em class="calibre9">Scope</em>'d variable to hand back from an LHS look-up, and <em class="calibre9">Engine</em> would throw a <code class="calibre14">ReferenceError</code> similarly to the RHS case.</p>
<p class="calibre8">Now, if a variable is found for an RHS look-up, but you try to do something with its value that is impossible, such as trying to execute-as-function a non-function value, or reference a property on a <code class="calibre14">null</code> or <code class="calibre14">undefined</code> value, then <em class="calibre9">Engine</em> throws a different kind of error, called a <code class="calibre14">TypeError</code>.</p>
<p class="calibre8"><code class="calibre14">ReferenceError</code> is <em class="calibre9">Scope</em> resolution-failure related, whereas <code class="calibre14">TypeError</code> implies that <em class="calibre9">Scope</em> resolution was successful, but that there was an illegal/impossible action attempted against the result.</p>
<h2 class="calibre10"><a id="user-content-review-tldr" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#review-tldr"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Review (TL;DR)</h2>
<p class="calibre8">Scope is the set of rules that determines where and how a variable (identifier) can be looked-up. This look-up may be for the purposes of assigning to the variable, which is an LHS (left-hand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (right-hand-side) reference.</p>
<p class="calibre8">LHS references result from assignment operations. <em class="calibre9">Scope</em>-related assignments can occur either with the <code class="calibre14">=</code> operator or by passing arguments to (assign to) function parameters.</p>
<p class="calibre8">The JavaScript <em class="calibre9">Engine</em> first compiles code before it executes, and in so doing, it splits up statements like <code class="calibre14">var a = 2;</code> into two separate steps:</p>
<ol class="calibre13">
<li class="calibre4">
<p class="calibre8">First, <code class="calibre14">var a</code> to declare it in that <em class="calibre9">Scope</em>. This is performed at the beginning, before code execution.</p>
</li>
<li class="calibre4">
<p class="calibre8">Later, <code class="calibre14">a = 2</code> to look up the variable (LHS reference) and assign to it if found.</p>
</li>
</ol>
<p class="calibre8">Both LHS and RHS reference look-ups start at the currently executing <em class="calibre9">Scope</em>, and if need be (that is, they don't find what they're looking for there), they work their way up the nested <em class="calibre9">Scope</em>, one scope (floor) at a time, looking for the identifier, until they get to the global (top floor) and stop, and either find it, or don't.</p>
<p class="calibre8">Unfulfilled RHS references result in <code class="calibre14">ReferenceError</code>s being thrown. Unfulfilled LHS references result in an automatic, implicitly-created global of that name (if not in "Strict Mode" [^note-strictmode]), or a <code class="calibre14">ReferenceError</code> (if in "Strict Mode" [^note-strictmode]).</p>
<h3 class="calibre15"><a id="user-content-quiz-answers" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_2/ch1.xhtml#quiz-answers"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Quiz Answers</h3>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>a</span>) {
	<span>var</span> b <span>=</span> a;
	<span>return</span> a <span>+</span> b;
}

<span>var</span> c <span>=</span> <span>foo</span>( <span>2</span> );</pre></div>
<ol class="calibre13">
<li class="calibre4">
<p class="calibre8">Identify all the LHS look-ups (there are 3!).</p>
<p class="calibre8"><strong class="calibre12"><code class="calibre14">c = ..</code>, <code class="calibre14">a = 2</code> (implicit param assignment) and <code class="calibre14">b = ..</code></strong></p>
</li>
<li class="calibre4">
<p class="calibre8">Identify all the RHS look-ups (there are 4!).</p>
<p class="calibre8"><strong class="calibre12"><code class="calibre14">foo(2..</code>, <code class="calibre14">= a;</code>, <code class="calibre14">a + ..</code> and <code class="calibre14">.. + b</code></strong></p>
</li>
</ol>
<p class="calibre8">[^note-strictmode]: MDN: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode">Strict Mode</a></p>
</div>
</div><div class="calibre_navbar">
<hr class="calibre6"/>
<p class="calibre11">This article was downloaded by <strong class="calibre12">calibre</strong> from <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md" rel="calibre-downloaded-from">https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md</a></p>
<br class="calibre5"/><br class="calibre5"/> | <a href="../index.html#article_2">Section menu</a> | <a href="../../index.html#feed_0">Main menu</a> | </div></body></html>
