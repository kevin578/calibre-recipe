<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>You-Dont-Know-JS/ch2.md at master · getify/You-Dont-Know-JS · GitHub</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><div class="calibre_navbar">| <a href="../article_4/index.html">Next</a> | <a href="../index.html#article_3">Section menu</a> | <a href="../../index.html#feed_0">Main menu</a> | <a href="../article_2/index.html">Previous</a> | <hr class="calibre6"/>
</div><div class="calibre5"><div itemprop="text" class="calibre5"><h1 class="calibre7"><a id="user-content-you-dont-know-js-scope--closures" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#you-dont-know-js-scope--closures"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>You Don't Know JS: Scope &amp; Closures</h1>
<h1 class="calibre7"><a id="user-content-chapter-2-lexical-scope" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#chapter-2-lexical-scope"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Chapter 2: Lexical Scope</h1>
<p class="calibre8">In Chapter 1, we defined "scope" as the set of rules that govern how the <em class="calibre9">Engine</em> can look up a variable by its identifier name and find it, either in the current <em class="calibre9">Scope</em>, or in any of the <em class="calibre9">Nested Scopes</em> it's contained within.</p>
<p class="calibre8">There are two predominant models for how scope works. The first of these is by far the most common, used by the vast majority of programming languages. It's called <strong class="calibre12">Lexical Scope</strong>, and we will examine it in-depth. The other model, which is still used by some languages (such as Bash scripting, some modes in Perl, etc.) is called <strong class="calibre12">Dynamic Scope</strong>.</p>
<p class="calibre8">Dynamic Scope is covered in Appendix A. I mention it here only to provide a contrast with Lexical Scope, which is the scope model that JavaScript employs.</p>
<h2 class="calibre10"><a id="user-content-lex-time" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#lex-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Lex-time</h2>
<p class="calibre8">As we discussed in Chapter 1, the first traditional phase of a standard language compiler is called lexing (aka, tokenizing). If you recall, the lexing process examines a string of source code characters and assigns semantic meaning to the tokens as a result of some stateful parsing.</p>
<p class="calibre8">It is this concept which provides the foundation to understand what lexical scope is and where the name comes from.</p>
<p class="calibre8">To define it somewhat circularly, lexical scope is scope that is defined at lexing time. In other words, lexical scope is based on where variables and blocks of scope are authored, by you, at write time, and thus is (mostly) set in stone by the time the lexer processes your code.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> We will see in a little bit there are some ways to cheat lexical scope, thereby modifying it after the lexer has passed by, but these are frowned upon. It is considered best practice to treat lexical scope as, in fact, lexical-only, and thus entirely author-time in nature.</p>
<p class="calibre8">Let's consider this block of code:</p>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>a</span>) {

	<span>var</span> b <span>=</span> a <span>*</span> <span>2</span>;

	<span>function</span> <span>bar</span>(<span>c</span>) {
		<span>console</span>.<span>log</span>( a, b, c );
	}

	<span>bar</span>(b <span>*</span> <span>3</span>);
}

<span>foo</span>( <span>2</span> ); <span><span>//</span> 2 4 12</span></pre></div>
<p class="calibre8">There are three nested scopes inherent in this code example. It may be helpful to think about these scopes as bubbles inside of each other.</p>
<p class="calibre8"><a target="_blank" href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/fig2.png"><img src="images/img1.png" class="calibre2"/></a></p>
<p class="calibre8"><strong class="calibre12">Bubble 1</strong> encompasses the global scope, and has just one identifier in it: <code class="calibre14">foo</code>.</p>
<p class="calibre8"><strong class="calibre12">Bubble 2</strong> encompasses the scope of <code class="calibre14">foo</code>, which includes the three identifiers: <code class="calibre14">a</code>, <code class="calibre14">bar</code> and <code class="calibre14">b</code>.</p>
<p class="calibre8"><strong class="calibre12">Bubble 3</strong> encompasses the scope of <code class="calibre14">bar</code>, and it includes just one identifier: <code class="calibre14">c</code>.</p>
<p class="calibre8">Scope bubbles are defined by where the blocks of scope are written, which one is nested inside the other, etc. In the next chapter, we'll discuss different units of scope, but for now, let's just assume that each function creates a new bubble of scope.</p>
<p class="calibre8">The bubble for <code class="calibre14">bar</code> is entirely contained within the bubble for <code class="calibre14">foo</code>, because (and only because) that's where we chose to define the function <code class="calibre14">bar</code>.</p>
<p class="calibre8">Notice that these nested bubbles are strictly nested. We're not talking about Venn diagrams where the bubbles can cross boundaries. In other words, no bubble for some function can simultaneously exist (partially) inside two other outer scope bubbles, just as no function can partially be inside each of two parent functions.</p>
<h3 class="calibre15"><a id="user-content-look-ups" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#look-ups"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Look-ups</h3>
<p class="calibre8">The structure and relative placement of these scope bubbles fully explains to the <em class="calibre9">Engine</em> all the places it needs to look to find an identifier.</p>
<p class="calibre8">In the above code snippet, the <em class="calibre9">Engine</em> executes the <code class="calibre14">console.log(..)</code> statement and goes looking for the three referenced variables <code class="calibre14">a</code>, <code class="calibre14">b</code>, and <code class="calibre14">c</code>. It first starts with the innermost scope bubble, the scope of the <code class="calibre14">bar(..)</code> function. It won't find <code class="calibre14">a</code> there, so it goes up one level, out to the next nearest scope bubble, the scope of <code class="calibre14">foo(..)</code>. It finds <code class="calibre14">a</code> there, and so it uses that <code class="calibre14">a</code>. Same thing for <code class="calibre14">b</code>. But <code class="calibre14">c</code>, it does find inside of <code class="calibre14">bar(..)</code>.</p>
<p class="calibre8">Had there been a <code class="calibre14">c</code> both inside of <code class="calibre14">bar(..)</code> and inside of <code class="calibre14">foo(..)</code>, the <code class="calibre14">console.log(..)</code> statement would have found and used the one in <code class="calibre14">bar(..)</code>, never getting to the one in <code class="calibre14">foo(..)</code>.</p>
<p class="calibre8"><strong class="calibre12">Scope look-up stops once it finds the first match</strong>. The same identifier name can be specified at multiple layers of nested scope, which is called "shadowing" (the inner identifier "shadows" the outer identifier). Regardless of shadowing, scope look-up always starts at the innermost scope being executed at the time, and works its way outward/upward until the first match, and stops.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> Global variables are also automatically properties of the global object (<code class="calibre14">window</code> in browsers, etc.), so it <em class="calibre9">is</em> possible to reference a global variable not directly by its lexical name, but instead indirectly as a property reference of the global object.</p>
<p class="calibre8">This technique gives access to a global variable which would otherwise be inaccessible due to it being shadowed. However, non-global shadowed variables cannot be accessed.</p>
<p class="calibre8">No matter <em class="calibre9">where</em> a function is invoked from, or even <em class="calibre9">how</em> it is invoked, its lexical scope is <strong class="calibre12">only</strong> defined by where the function was declared.</p>
<p class="calibre8">The lexical scope look-up process <em class="calibre9">only</em> applies to first-class identifiers, such as the <code class="calibre14">a</code>, <code class="calibre14">b</code>, and <code class="calibre14">c</code>. If you had a reference to <code class="calibre14">foo.bar.baz</code> in a piece of code, the lexical scope look-up would apply to finding the <code class="calibre14">foo</code> identifier, but once it locates that variable, object property-access rules take over to resolve the <code class="calibre14">bar</code> and <code class="calibre14">baz</code> properties, respectively.</p>
<h2 class="calibre10"><a id="user-content-cheating-lexical" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#cheating-lexical"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Cheating Lexical</h2>
<p class="calibre8">If lexical scope is defined only by where a function is declared, which is entirely an author-time decision, how could there possibly be a way to "modify" (aka, cheat) lexical scope at run-time?</p>
<p class="calibre8">JavaScript has two such mechanisms. Both of them are equally frowned-upon in the wider community as bad practices to use in your code. But the typical arguments against them are often missing the most important point: <strong class="calibre12">cheating lexical scope leads to poorer performance.</strong></p>
<p class="calibre8">Before I explain the performance issue, though, let's look at how these two mechanisms work.</p>
<h3 class="calibre15"><a id="user-content-eval" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#eval"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a><code class="calibre18">eval</code></h3>
<p class="calibre8">The <code class="calibre14">eval(..)</code> function in JavaScript takes a string as an argument, and treats the contents of the string as if it had actually been authored code at that point in the program. In other words, you can programmatically generate code inside of your authored code, and run the generated code as if it had been there at author time.</p>
<p class="calibre8">Evaluating <code class="calibre14">eval(..)</code> (pun intended) in that light, it should be clear how <code class="calibre14">eval(..)</code> allows you to modify the lexical scope environment by cheating and pretending that author-time (aka, lexical) code was there all along.</p>
<p class="calibre8">On subsequent lines of code after an <code class="calibre14">eval(..)</code> has executed, the <em class="calibre9">Engine</em> will not "know" or "care" that the previous code in question was dynamically interpreted and thus modified the lexical scope environment. The <em class="calibre9">Engine</em> will simply perform its lexical scope look-ups as it always does.</p>
<p class="calibre8">Consider the following code:</p>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>str</span>, <span>a</span>) {
	<span>eval</span>( str ); <span><span>//</span> cheating!</span>
	<span>console</span>.<span>log</span>( a, b );
}

<span>var</span> b <span>=</span> <span>2</span>;

<span>foo</span>( <span><span>"</span>var b = 3;<span>"</span></span>, <span>1</span> ); <span><span>//</span> 1 3</span></pre></div>
<p class="calibre8">The string <code class="calibre14">"var b = 3;"</code> is treated, at the point of the <code class="calibre14">eval(..)</code> call, as code that was there all along. Because that code happens to declare a new variable <code class="calibre14">b</code>, it modifies the existing lexical scope of <code class="calibre14">foo(..)</code>. In fact, as mentioned above, this code actually creates variable <code class="calibre14">b</code> inside of <code class="calibre14">foo(..)</code> that shadows the <code class="calibre14">b</code> that was declared in the outer (global) scope.</p>
<p class="calibre8">When the <code class="calibre14">console.log(..)</code> call occurs, it finds both <code class="calibre14">a</code> and <code class="calibre14">b</code> in the scope of <code class="calibre14">foo(..)</code>, and never finds the outer <code class="calibre14">b</code>. Thus, we print out "1 3" instead of "1 2" as would have normally been the case.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> In this example, for simplicity's sake, the string of "code" we pass in was a fixed literal. But it could easily have been programmatically created by adding characters together based on your program's logic. <code class="calibre14">eval(..)</code> is usually used to execute dynamically created code, as dynamically evaluating essentially static code from a string literal would provide no real benefit to just authoring the code directly.</p>
<p class="calibre8">By default, if a string of code that <code class="calibre14">eval(..)</code> executes contains one or more declarations (either variables or functions), this action modifies the existing lexical scope in which the <code class="calibre14">eval(..)</code> resides. Technically, <code class="calibre14">eval(..)</code> can be invoked "indirectly", through various tricks (beyond our discussion here), which causes it to instead execute in the context of the global scope, thus modifying it. But in either case, <code class="calibre14">eval(..)</code> can at runtime modify an author-time lexical scope.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> <code class="calibre14">eval(..)</code> when used in a strict-mode program operates in its own lexical scope, which means declarations made inside of the <code class="calibre14">eval()</code> do not actually modify the enclosing scope.</p>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>str</span>) {
   <span><span>"</span>use strict<span>"</span></span>;
   <span>eval</span>( str );
   <span>console</span>.<span>log</span>( a ); <span><span>//</span> ReferenceError: a is not defined</span>
}

<span>foo</span>( <span><span>"</span>var a = 2<span>"</span></span> );</pre></div>
<p class="calibre8">There are other facilities in JavaScript which amount to a very similar effect to <code class="calibre14">eval(..)</code>. <code class="calibre14">setTimeout(..)</code> and <code class="calibre14">setInterval(..)</code> <em class="calibre9">can</em> take a string for their respective first argument, the contents of which are <code class="calibre14">eval</code>uated as the code of a dynamically-generated function. This is old, legacy behavior and long-since deprecated. Don't do it!</p>
<p class="calibre8">The <code class="calibre14">new Function(..)</code> function constructor similarly takes a string of code in its <strong class="calibre12">last</strong> argument to turn into a dynamically-generated function (the first argument(s), if any, are the named parameters for the new function). This function-constructor syntax is slightly safer than <code class="calibre14">eval(..)</code>, but it should still be avoided in your code.</p>
<p class="calibre8">The use-cases for dynamically generating code inside your program are incredibly rare, as the performance degradations are almost never worth the capability.</p>
<h3 class="calibre15"><a id="user-content-with" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#with"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a><code class="calibre18">with</code></h3>
<p class="calibre8">The other frowned-upon (and now deprecated!) feature in JavaScript which cheats lexical scope is the <code class="calibre14">with</code> keyword. There are multiple valid ways that <code class="calibre14">with</code> can be explained, but I will choose here to explain it from the perspective of how it interacts with and affects lexical scope.</p>
<p class="calibre8"><code class="calibre14">with</code> is typically explained as a short-hand for making multiple property references against an object <em class="calibre9">without</em> repeating the object reference itself each time.</p>
<p class="calibre8">For example:</p>
<div class="calibre5"><pre class="calibre16"><span>var</span> obj <span>=</span> {
	a<span>:</span> <span>1</span>,
	b<span>:</span> <span>2</span>,
	c<span>:</span> <span>3</span>
};

<span><span>//</span> more "tedious" to repeat "obj"</span>
<span>obj</span>.<span>a</span> <span>=</span> <span>2</span>;
<span>obj</span>.<span>b</span> <span>=</span> <span>3</span>;
<span>obj</span>.<span>c</span> <span>=</span> <span>4</span>;

<span><span>//</span> "easier" short-hand</span>
<span>with</span> (obj) {
	a <span>=</span> <span>3</span>;
	b <span>=</span> <span>4</span>;
	c <span>=</span> <span>5</span>;
}</pre></div>
<p class="calibre8">However, there's much more going on here than just a convenient short-hand for object property access. Consider:</p>
<div class="calibre5"><pre class="calibre16"><span>function</span> <span>foo</span>(<span>obj</span>) {
	<span>with</span> (obj) {
		a <span>=</span> <span>2</span>;
	}
}

<span>var</span> o1 <span>=</span> {
	a<span>:</span> <span>3</span>
};

<span>var</span> o2 <span>=</span> {
	b<span>:</span> <span>3</span>
};

<span>foo</span>( o1 );
<span>console</span>.<span>log</span>( <span>o1</span>.<span>a</span> ); <span><span>//</span> 2</span>

<span>foo</span>( o2 );
<span>console</span>.<span>log</span>( <span>o2</span>.<span>a</span> ); <span><span>//</span> undefined</span>
<span>console</span>.<span>log</span>( a ); <span><span>//</span> 2 -- Oops, leaked global!</span></pre></div>
<p class="calibre8">In this code example, two objects <code class="calibre14">o1</code> and <code class="calibre14">o2</code> are created. One has an <code class="calibre14">a</code> property, and the other does not. The <code class="calibre14">foo(..)</code> function takes an object reference <code class="calibre14">obj</code> as an argument, and calls <code class="calibre14">with (obj) { .. }</code> on the reference. Inside the <code class="calibre14">with</code> block, we make what appears to be a normal lexical reference to a variable <code class="calibre14">a</code>, an LHS reference in fact (see Chapter 1), to assign to it the value of <code class="calibre14">2</code>.</p>
<p class="calibre8">When we pass in <code class="calibre14">o1</code>, the <code class="calibre14">a = 2</code> assignment finds the property <code class="calibre14">o1.a</code> and assigns it the value <code class="calibre14">2</code>, as reflected in the subsequent <code class="calibre14">console.log(o1.a)</code> statement. However, when we pass in <code class="calibre14">o2</code>, since it does not have an <code class="calibre14">a</code> property, no such property is created, and <code class="calibre14">o2.a</code> remains <code class="calibre14">undefined</code>.</p>
<p class="calibre8">But then we note a peculiar side-effect, the fact that a global variable <code class="calibre14">a</code> was created by the <code class="calibre14">a = 2</code> assignment. How can this be?</p>
<p class="calibre8">The <code class="calibre14">with</code> statement takes an object, one which has zero or more properties, and <strong class="calibre12">treats that object as if <em class="calibre9">it</em> is a wholly separate lexical scope</strong>, and thus the object's properties are treated as lexically defined identifiers in that "scope".</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> Even though a <code class="calibre14">with</code> block treats an object like a lexical scope, a normal <code class="calibre14">var</code> declaration inside that <code class="calibre14">with</code> block will not be scoped to that <code class="calibre14">with</code> block, but instead the containing function scope.</p>
<p class="calibre8">While the <code class="calibre14">eval(..)</code> function can modify existing lexical scope if it takes a string of code with one or more declarations in it, the <code class="calibre14">with</code> statement actually creates a <strong class="calibre12">whole new lexical scope</strong> out of thin air, from the object you pass to it.</p>
<p class="calibre8">Understood in this way, the "scope" declared by the <code class="calibre14">with</code> statement when we passed in <code class="calibre14">o1</code> was <code class="calibre14">o1</code>, and that "scope" had an "identifier" in it which corresponds to the <code class="calibre14">o1.a</code> property. But when we used <code class="calibre14">o2</code> as the "scope", it had no such <code class="calibre14">a</code> "identifier" in it, and so the normal rules of LHS identifier look-up (see Chapter 1) occurred.</p>
<p class="calibre8">Neither the "scope" of <code class="calibre14">o2</code>, nor the scope of <code class="calibre14">foo(..)</code>, nor the global scope even, has an <code class="calibre14">a</code> identifier to be found, so when <code class="calibre14">a = 2</code> is executed, it results in the automatic-global being created (since we're in non-strict mode).</p>
<p class="calibre8">It is a strange sort of mind-bending thought to see <code class="calibre14">with</code> turning, at runtime, an object and its properties into a "scope" <em class="calibre9">with</em> "identifiers". But that is the clearest explanation I can give for the results we see.</p>
<p class="calibre8"><strong class="calibre12">Note:</strong> In addition to being a bad idea to use, both <code class="calibre14">eval(..)</code> and <code class="calibre14">with</code> are affected (restricted) by Strict Mode. <code class="calibre14">with</code> is outright disallowed, whereas various forms of indirect or unsafe <code class="calibre14">eval(..)</code> are disallowed while retaining the core functionality.</p>
<h3 class="calibre15"><a id="user-content-performance" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#performance"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Performance</h3>
<p class="calibre8">Both <code class="calibre14">eval(..)</code> and <code class="calibre14">with</code> cheat the otherwise author-time defined lexical scope by modifying or creating new lexical scope at runtime.</p>
<p class="calibre8">So, what's the big deal, you ask? If they offer more sophisticated functionality and coding flexibility, aren't these <em class="calibre9">good</em> features? <strong class="calibre12">No.</strong></p>
<p class="calibre8">The JavaScript <em class="calibre9">Engine</em> has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.</p>
<p class="calibre8">But if the <em class="calibre9">Engine</em> finds an <code class="calibre14">eval(..)</code> or <code class="calibre14">with</code> in the code, it essentially has to <em class="calibre9">assume</em> that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to <code class="calibre14">eval(..)</code> to modify the lexical scope, or the contents of the object you may pass to <code class="calibre14">with</code> to create a new lexical scope to be consulted.</p>
<p class="calibre8">In other words, in the pessimistic sense, most of those optimizations it <em class="calibre9">would</em> make are pointless if <code class="calibre14">eval(..)</code> or <code class="calibre14">with</code> are present, so it simply doesn't perform the optimizations <em class="calibre9">at all</em>.</p>
<p class="calibre8">Your code will almost certainly tend to run slower simply by the fact that you include an <code class="calibre14">eval(..)</code> or <code class="calibre14">with</code> anywhere in the code. No matter how smart the <em class="calibre9">Engine</em> may be about trying to limit the side-effects of these pessimistic assumptions, <strong class="calibre12">there's no getting around the fact that without the optimizations, code runs slower.</strong></p>
<h2 class="calibre10"><a id="user-content-review-tldr" aria-hidden="true" class="anchor" href="https://github.com/private/var/folders/gf/gmkqgf0j39x4np1wqmzc8t6jxsyk_x/C/calibre_3.6.0_tmp_zr8BWh/KthVmk_plumber/feed_0/article_3/ch2.xhtml#review-tldr"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" aria-hidden="true" class="octicon octicon-link" version="1.1"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"/></svg></a>Review (TL;DR)</h2>
<p class="calibre8">Lexical scope means that scope is defined by author-time decisions of where functions are declared. The lexing phase of compilation is essentially able to know where and how all identifiers are declared, and thus predict how they will be looked-up during execution.</p>
<p class="calibre8">Two mechanisms in JavaScript can "cheat" lexical scope: <code class="calibre14">eval(..)</code> and <code class="calibre14">with</code>. The former can modify existing lexical scope (at runtime) by evaluating a string of "code" which has one or more declarations in it. The latter essentially creates a whole new lexical scope (again, at runtime) by treating an object reference <em class="calibre9">as</em> a "scope" and that object's properties as scoped identifiers.</p>
<p class="calibre8">The downside to these mechanisms is that it defeats the <em class="calibre9">Engine</em>'s ability to perform compile-time optimizations regarding scope look-up, because the <em class="calibre9">Engine</em> has to assume pessimistically that such optimizations will be invalid. Code <em class="calibre9">will</em> run slower as a result of using either feature. <strong class="calibre12">Don't use them.</strong></p>
</div>
</div><div class="calibre_navbar">
<hr class="calibre6"/>
<p class="calibre11">This article was downloaded by <strong class="calibre12">calibre</strong> from <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch2.md" rel="calibre-downloaded-from">https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch2.md</a></p>
<br class="calibre5"/><br class="calibre5"/> | <a href="../index.html#article_3">Section menu</a> | <a href="../../index.html#feed_0">Main menu</a> | </div></body></html>
